// ======================================================================
◇ Begin File: App.xaml
// -----------------------------------

   1 | <Application x:Class="CodeConsolidator.App"<Application x:Class="CodeConsolidator.App"
   2 |              xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   3 |              xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   4 |              StartupUri="Views/MainWindow.xaml">
   5 |     <Application.Resources>
   6 |     </Application.Resources>
   7 | </Application>

// -----------------------------------
◇ End File: App.xaml
// ======================================================================

// ======================================================================
◈ Begin File: App.xaml.cs
// -----------------------------------

   1 | using System.Configuration;
   2 | using System.Data;
   3 | using System.Windows;
   4 | 
   5 | namespace CodeConsolidator
   6 | {
   7 |     /// <summary>
   8 |     /// Interaction logic for App.xaml
   9 |     /// </summary>
  10 |     public partial class App : Application
  11 |     {
  12 |     }
  13 | 
  14 | }
  15 | 

// -----------------------------------
◈ End File: App.xaml.cs
// ======================================================================

// ======================================================================
◈ Begin File: AssemblyInfo.cs
// -----------------------------------

   1 | using System.Windows;
   2 | 
   3 | [assembly: ThemeInfo(
   4 |     ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
   5 |                                                 //(used if a resource is not found in the page,
   6 |                                                 // or application resource dictionaries)
   7 |     ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
   8 |                                                 //(used if a resource is not found in the page,
   9 |                                                 // app, or any theme specific resource dictionaries)
  10 | )]
  11 | 

// -----------------------------------
◈ End File: AssemblyInfo.cs
// ======================================================================

// ======================================================================
⚙ Begin File: CodeConsolidator.csproj
// -----------------------------------

   1 | <Project Sdk="Microsoft.NET.Sdk">
   2 | 
   3 |   <PropertyGroup>
   4 |     <OutputType>WinExe</OutputType>
   5 |     <TargetFramework>net8.0-windows</TargetFramework>
   6 |     <Nullable>enable</Nullable>
   7 |     <ImplicitUsings>enable</ImplicitUsings>
   8 |     <UseWPF>true</UseWPF>
   9 |     <ApplicationIcon>Icons\icon_243.ico</ApplicationIcon>
  10 |   </PropertyGroup>
  11 | 
  12 |   <ItemGroup>
  13 |     <Resource Include="Icons\icon_243.ico">
  14 |       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  15 |     </Resource>
  16 |   </ItemGroup>
  17 | 
  18 |   <ItemGroup>
  19 |     <PackageReference Include="System.Drawing.Common" Version="9.0.3" />
  20 |   </ItemGroup>
  21 | 
  22 |   <ItemGroup>
  23 |     <Resource Include="Icons\icon_228.png">
  24 |       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  25 |     </Resource>
  26 |     <Resource Include="Icons\icon_233.png">
  27 |       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  28 |     </Resource>
  29 |   </ItemGroup>
  30 | 
  31 | </Project>
  32 | 

// -----------------------------------
⚙ End File: CodeConsolidator.csproj
// ======================================================================

// ======================================================================
◈ Begin File: Models\FileProcessor.cs
// -----------------------------------

   1 | using System;
   2 | using System.Collections.Generic;
   3 | using System.IO;
   4 | 
   5 | namespace CodeConsolidator.Models
   6 | {
   7 |     public class FileProcessor
   8 |     {
   9 |         public List<string> GetFilteredFiles(string folderPath, bool searchSubfolders)
  10 |         {
  11 |             var filteredFiles = new List<string>();
  12 |             try
  13 |             {
  14 |                 var searchOption = searchSubfolders ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
  15 |                 var allFiles = Directory.GetFiles(folderPath, "*.*", searchOption);
  16 |                 var temporaryPatterns = new List<string> { "~$*", "*.tmp", "*.bak", "*.swp" };
  17 | 
  18 |                 filteredFiles = allFiles.Where(filePath =>
  19 |                 {
  20 |                     var fileName = Path.GetFileName(filePath);
  21 |                     var directoryName = Path.GetDirectoryName(filePath);
  22 | 
  23 |                     return !temporaryPatterns.Any(pattern => fileName.StartsWith(pattern.Trim('*'))) &&
  24 |                            !directoryName.Contains("bin") &&
  25 |                            !directoryName.Contains("obj") &&
  26 |                            !directoryName.Contains("deprecated") &&
  27 |                            !directoryName.Contains("Temp") &&
  28 |                            (filePath.EndsWith(".cs") || filePath.EndsWith(".xaml") || filePath.EndsWith(".csproj") || filePath.EndsWith(".sln"));
  29 |                 }).ToList();
  30 |             }
  31 |             catch (Exception ex)
  32 |             {
  33 |                 throw new Exception($"Error processing files: {ex.Message}");
  34 |             }
  35 | 
  36 |             return filteredFiles;
  37 |         }
  38 |     }
  39 | }
  40 | 

// -----------------------------------
◈ End File: Models\FileProcessor.cs
// ======================================================================

// ======================================================================
◈ Begin File: Services\SyntaxHighlighter.cs
// -----------------------------------

   1 | using System;
   2 | using System.Linq;
   3 | using System.Windows;
   4 | using System.Windows.Documents;
   5 | using System.Windows.Media;
   6 | using System.Windows.Shapes;
   7 | 
   8 | namespace CodeConsolidator.Services
   9 | {
  10 |     public class SyntaxHighlighter
  11 |     {
  12 |         private readonly bool _darkMode;
  13 | 
  14 |         public SyntaxHighlighter(bool darkMode)
  15 |         {
  16 |             _darkMode = darkMode;
  17 |         }
  18 | 
  19 |         public void HighlightCSharpCode(string code, FlowDocument flowDocument)
  20 |         {
  21 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
  22 |             var keywords = new[] { "using", "namespace", "class", "void", "return", "if", "else", "for", "foreach", "while", "do", "switch", "case", "break", "continue", "var", "new", "this", "base", "true", "false", "null" };
  23 |             int lineNumber = 1;
  24 | 
  25 | 
  26 |             for (int i = 0; i < lines.Length; i++)
  27 |             //foreach (var line in lines)
  28 |             {
  29 |                 var line = lines[i];
  30 | 
  31 |                 var paragraph = CreateParagraph(lineNumber++, line);
  32 | 
  33 |                 foreach (var keyword in keywords)
  34 |                 {
  35 |                     int index = 0;
  36 |                     while (index >= 0 && index < line.Length)
  37 |                     {
  38 |                         index = line.IndexOf(keyword, index, StringComparison.Ordinal);
  39 |                         if (index < 0) break;
  40 | 
  41 |                         bool isWholeWord = (index == 0 || !char.IsLetterOrDigit(line[index - 1])) &&
  42 |                                            (index + keyword.Length >= line.Length ||
  43 |                                             !char.IsLetterOrDigit(line[index + keyword.Length]));
  44 | 
  45 |                         if (isWholeWord)
  46 |                         {
  47 |                             AddTextBeforeKeyword(paragraph, line.Substring(0, index));
  48 |                             AddHighlightedKeyword(paragraph, keyword);
  49 |                             line = line.Substring(index + keyword.Length);
  50 |                             index = 0;
  51 |                         }
  52 |                         else
  53 |                         {
  54 |                             index += keyword.Length;
  55 |                         }
  56 |                     }
  57 |                 }
  58 | 
  59 |                 AddRemainingText(paragraph, line);
  60 |                 flowDocument.Blocks.Add(paragraph);
  61 |             }
  62 |         }
  63 | 
  64 |         public void HighlightXamlCode(string code, FlowDocument flowDocument)
  65 |         {
  66 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
  67 |             int lineNumber = 1;
  68 | 
  69 |             foreach (var line in lines)
  70 |             {
  71 |                 var paragraph = CreateParagraph(lineNumber++, line);
  72 |                 var processedLine = line;
  73 | 
  74 |                 int tagStart = 0;
  75 |                 while ((tagStart = processedLine.IndexOf('<')) >= 0)
  76 |                 {
  77 |                     AddTextBeforeTag(paragraph, processedLine.Substring(0, tagStart));
  78 |                     processedLine = processedLine.Substring(tagStart);
  79 |                     tagStart = 0;
  80 | 
  81 |                     int tagEnd = processedLine.IndexOf('>');
  82 |                     if (tagEnd < 0)
  83 |                     {
  84 |                         AddUnclosedTag(paragraph, processedLine);
  85 |                         break;
  86 |                     }
  87 | 
  88 |                     var tag = processedLine.Substring(0, tagEnd + 1);
  89 |                     AddHighlightedTag(paragraph, tag);
  90 |                     processedLine = processedLine.Substring(tagEnd + 1);
  91 |                 }
  92 | 
  93 |                 AddRemainingText(paragraph, processedLine);
  94 |                 flowDocument.Blocks.Add(paragraph);
  95 |             }
  96 |         }
  97 | 
  98 |         // Add this method to the SyntaxHighlighter class in Services/SyntaxHighlighter.cs
  99 |         public void HighlightCsProjCode(string code, FlowDocument flowDocument)
 100 |         {
 101 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
 102 |             int lineNumber = 1;
 103 | 
 104 |             foreach (var line in lines)
 105 |             {
 106 |                 var paragraph = CreateParagraph(lineNumber++, line);
 107 |                 var processedLine = line;
 108 | 
 109 |                 // Highlight XML tags
 110 |                 int tagStart = 0;
 111 |                 while ((tagStart = processedLine.IndexOf('<')) >= 0)
 112 |                 {
 113 |                     AddTextBeforeTag(paragraph, processedLine.Substring(0, tagStart));
 114 |                     processedLine = processedLine.Substring(tagStart);
 115 |                     tagStart = 0;
 116 | 
 117 |                     int tagEnd = processedLine.IndexOf('>');
 118 |                     if (tagEnd < 0)
 119 |                     {
 120 |                         AddUnclosedTag(paragraph, processedLine);
 121 |                         break;
 122 |                     }
 123 | 
 124 |                     var tag = processedLine.Substring(0, tagEnd + 1);
 125 | 
 126 |                     // Special highlighting for important csproj elements
 127 |                     if (tag.StartsWith("<Project") || tag.StartsWith("</Project") ||
 128 |                         tag.StartsWith("<PropertyGroup") || tag.StartsWith("</PropertyGroup") ||
 129 |                         tag.StartsWith("<ItemGroup") || tag.StartsWith("</ItemGroup"))
 130 |                     {
 131 |                         paragraph.Inlines.Add(new Run(tag)
 132 |                         {
 133 |                             Foreground = _darkMode ? Brushes.LightGreen : Brushes.DarkGreen,
 134 |                             FontWeight = FontWeights.Bold
 135 |                         });
 136 |                     }
 137 |                     else if (tag.StartsWith("<PackageReference") || tag.StartsWith("<ProjectReference") ||
 138 |                              tag.StartsWith("<Reference") || tag.StartsWith("<Compile") ||
 139 |                              tag.StartsWith("<None") || tag.StartsWith("<Content"))
 140 |                     {
 141 |                         paragraph.Inlines.Add(new Run(tag)
 142 |                         {
 143 |                             Foreground = _darkMode ? Brushes.LightBlue : Brushes.Blue
 144 |                         });
 145 |                     }
 146 |                     else
 147 |                     {
 148 |                         AddHighlightedTag(paragraph, tag);
 149 |                     }
 150 | 
 151 |                     processedLine = processedLine.Substring(tagEnd + 1);
 152 |                 }
 153 | 
 154 |                 AddRemainingText(paragraph, processedLine);
 155 |                 flowDocument.Blocks.Add(paragraph);
 156 |             }
 157 |         }
 158 | 
 159 |         public void HighlightSlnCode(string code, FlowDocument flowDocument)
 160 |         {
 161 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
 162 |             int lineNumber = 1;
 163 | 
 164 |             foreach (var line in lines)
 165 |             {
 166 |                 var paragraph = CreateParagraph(lineNumber++, line);
 167 | 
 168 |                 if (line.Trim().StartsWith("Project("))
 169 |                 {
 170 |                     // Highlight project references
 171 |                     AddHighlightedKeyword(paragraph, "Project");
 172 |                     AddTextBeforeKeyword(paragraph, line.Substring(0, line.IndexOf("Project")));
 173 |                     AddRemainingText(paragraph, line.Substring(line.IndexOf("Project") + "Project".Length));
 174 |                 }
 175 |                 else if (line.Trim().StartsWith("GlobalSection("))
 176 |                 {
 177 |                     // Highlight global sections
 178 |                     AddHighlightedKeyword(paragraph, "GlobalSection");
 179 |                     AddTextBeforeKeyword(paragraph, line.Substring(0, line.IndexOf("GlobalSection")));
 180 |                     AddRemainingText(paragraph, line.Substring(line.IndexOf("GlobalSection") + "GlobalSection".Length));
 181 |                 }
 182 |                 else
 183 |                 {
 184 |                     // Default text
 185 |                     AddRemainingText(paragraph, line);
 186 |                 }
 187 | 
 188 |                 flowDocument.Blocks.Add(paragraph);
 189 |             }
 190 |         }
 191 | 
 192 |         private Paragraph CreateParagraph(int lineNumber, string line)
 193 |         {
 194 |             var paragraph = new Paragraph();
 195 |             paragraph.Inlines.Add(new Run($"{lineNumber.ToString().PadLeft(4)} | ")
 196 |             {
 197 |                 Foreground = Brushes.Gray,
 198 |                 FontFamily = new FontFamily("Consolas")
 199 |             });
 200 |             return paragraph;
 201 |         }
 202 | 
 203 |         private void AddTextBeforeKeyword(Paragraph paragraph, string text)
 204 |         {
 205 |             paragraph.Inlines.Add(new Run(text));
 206 |         }
 207 | 
 208 |         private void AddHighlightedKeyword(Paragraph paragraph, string keyword)
 209 |         {
 210 |             paragraph.Inlines.Add(new Run(keyword)
 211 |             {
 212 |                 Foreground = _darkMode ? Brushes.LightBlue : Brushes.Blue,
 213 |                 FontWeight = FontWeights.Bold
 214 |             });
 215 |         }
 216 | 
 217 |         private void AddHighlightedTag(Paragraph paragraph, string tag)
 218 |         {
 219 |             paragraph.Inlines.Add(new Run(tag)
 220 |             {
 221 |                 Foreground = _darkMode ? Brushes.LightCoral : Brushes.DarkRed
 222 |             });
 223 |         }
 224 | 
 225 |         private void AddUnclosedTag(Paragraph paragraph, string tag)
 226 |         {
 227 |             paragraph.Inlines.Add(new Run(tag)
 228 |             {
 229 |                 Foreground = _darkMode ? Brushes.LightCoral : Brushes.DarkRed
 230 |             });
 231 |         }
 232 | 
 233 |         private void AddTextBeforeTag(Paragraph paragraph, string text)
 234 |         {
 235 |             paragraph.Inlines.Add(new Run(text));
 236 |         }
 237 | 
 238 |         private void AddRemainingText(Paragraph paragraph, string text)
 239 |         {
 240 |             if (!string.IsNullOrEmpty(text))
 241 |             {
 242 |                 paragraph.Inlines.Add(new Run(text));
 243 |             }
 244 |         }
 245 |     }
 246 | }
 247 | 

// -----------------------------------
◈ End File: Services\SyntaxHighlighter.cs
// ======================================================================

// ======================================================================
◈ Begin File: Services\ThemeService.cs
// -----------------------------------

   1 | using System.Windows;
   2 | using System.Windows.Controls;
   3 | using System.Windows.Media;
   4 | 
   5 | namespace CodeConsolidator.Services
   6 | {
   7 |     public class ThemeService
   8 |     {
   9 |         private readonly Window _window;
  10 |         private readonly RichTextBox _codeDisplay;
  11 |         private readonly TextBlock _statusText;
  12 |         private readonly Panel _controlPanel;
  13 | 
  14 |         private bool _darkMode;
  15 | 
  16 |         public ThemeService(Window window, RichTextBox codeDisplay, TextBlock statusText, Panel controlPanel)
  17 |         {
  18 |             _window = window;
  19 |             _codeDisplay = codeDisplay;
  20 |             _statusText = statusText;
  21 |             _controlPanel = controlPanel;
  22 |         }
  23 | 
  24 |         public bool IsDarkMode()
  25 |         {
  26 |             return _darkMode;
  27 |         }
  28 | 
  29 |         public void ToggleDarkMode()
  30 |         {
  31 |             _darkMode = !_darkMode;
  32 | 
  33 |             _window.Background = _darkMode ? Brushes.DarkSlateGray : Brushes.White;
  34 |             _window.Foreground = _darkMode ? Brushes.White : Brushes.Black;
  35 | 
  36 |             _codeDisplay.Background = _darkMode ? Brushes.DimGray : Brushes.White;
  37 |             _codeDisplay.Foreground = _darkMode ? Brushes.White : Brushes.Black;
  38 | 
  39 |             _statusText.Foreground = _darkMode ? Brushes.LightGray : Brushes.Gray;
  40 | 
  41 |             foreach (var child in _controlPanel.Children)
  42 |             {
  43 |                 if (child is Button button)
  44 |                 {
  45 |                     button.Background = _darkMode ? Brushes.SlateGray : SystemColors.ControlBrush;
  46 |                     button.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
  47 |                 }
  48 |                 else if (child is CheckBox checkBox)
  49 |                 {
  50 |                     checkBox.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
  51 |                 }
  52 |             }
  53 |         }
  54 |     }
  55 | }
  56 | 

// -----------------------------------
◈ End File: Services\ThemeService.cs
// ======================================================================

// ======================================================================
◈ Begin File: ViewModels\MainViewModel.cs
// -----------------------------------

   1 | using CodeConsolidator.Models;
   2 | using CodeConsolidator.Services;
   3 | using System.Collections.Generic;
   4 | using System.IO;
   5 | using System.Windows;
   6 | using System.Windows.Documents;
   7 | using System.Windows.Media;
   8 | 
   9 | namespace CodeConsolidator.ViewModels
  10 | {
  11 |     public class MainViewModel
  12 |     {
  13 |         private readonly FileProcessor _fileProcessor;
  14 |         private readonly SyntaxHighlighter _syntaxHighlighter;
  15 | 
  16 |         public MainViewModel(bool darkMode)
  17 |         {
  18 |             _fileProcessor = new FileProcessor();
  19 |             _syntaxHighlighter = new SyntaxHighlighter(darkMode);
  20 |         }
  21 | 
  22 |         public void ProcessFolder(string folderPath, bool recursive, FlowDocument flowDocument)
  23 |         {
  24 |             var filteredFiles = _fileProcessor.GetFilteredFiles(folderPath, recursive);
  25 | 
  26 |             flowDocument.Blocks.Clear();
  27 | 
  28 |             foreach (var filePath in filteredFiles)
  29 |             {
  30 |                 AddFileHeader(flowDocument, filePath, folderPath);
  31 |                 var fileContent = File.ReadAllText(filePath);
  32 | 
  33 |                 if (filePath.EndsWith(".cs"))
  34 |                 {
  35 |                     _syntaxHighlighter.HighlightCSharpCode(fileContent, flowDocument);
  36 |                 }
  37 |                 else if (filePath.EndsWith(".xaml"))
  38 |                 {
  39 |                     _syntaxHighlighter.HighlightXamlCode(fileContent, flowDocument);
  40 |                 }
  41 |                 else if (filePath.EndsWith(".csproj"))
  42 |                 {
  43 |                     _syntaxHighlighter.HighlightCsProjCode(fileContent, flowDocument);
  44 |                 }
  45 |                 else if (filePath.EndsWith(".sln"))
  46 |                 {
  47 |                     _syntaxHighlighter.HighlightSlnCode(fileContent, flowDocument);
  48 |                 }
  49 | 
  50 |                 AddFileFooter(flowDocument, filePath, folderPath);
  51 |             }
  52 |         }
  53 | 
  54 |         private void AddFileHeader(FlowDocument flowDocument, string filePath, string folderPath)
  55 |         {
  56 |             string fileIcon = filePath.EndsWith(".cs") ? "◈" :
  57 |                              filePath.EndsWith(".xaml") ? "◇" :
  58 |                              filePath.EndsWith(".csproj") ? "◉" : "⚙";
  59 |             var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue :
  60 |                              filePath.EndsWith(".xaml") ? Brushes.Orange :
  61 |                              filePath.EndsWith(".csproj") ? Brushes.MediumPurple : Brushes.Green;
  62 | 
  63 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
  64 |             {
  65 |                 Foreground = Brushes.Gray
  66 |             });
  67 | 
  68 |             flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} Begin File: {filePath.Substring(folderPath.Length + 1)}"))
  69 |             {
  70 |                 Foreground = headerColor,
  71 |                 FontWeight = FontWeights.Bold
  72 |             });
  73 | 
  74 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
  75 |             {
  76 |                 Foreground = Brushes.Gray
  77 |             });
  78 | 
  79 |             flowDocument.Blocks.Add(new Paragraph());
  80 |         }
  81 | 
  82 |         private void AddFileFooter(FlowDocument flowDocument, string filePath, string folderPath)
  83 |         {
  84 |             string fileIcon = filePath.EndsWith(".cs") ? "◈" :
  85 |                              filePath.EndsWith(".xaml") ? "◇" :
  86 |                              filePath.EndsWith(".csproj") ? "◉" : "⚙";
  87 |             var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue :
  88 |                              filePath.EndsWith(".xaml") ? Brushes.Orange :
  89 |                              filePath.EndsWith(".csproj") ? Brushes.MediumPurple : Brushes.Green;
  90 | 
  91 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
  92 |             {
  93 |                 Foreground = Brushes.Gray
  94 |             });
  95 | 
  96 |             flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} End File: {filePath.Substring(folderPath.Length + 1)}"))
  97 |             {
  98 |                 Foreground = headerColor,
  99 |                 FontWeight = FontWeights.Bold
 100 |             });
 101 | 
 102 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
 103 |             {
 104 |                 Foreground = Brushes.Gray
 105 |             });
 106 | 
 107 |             flowDocument.Blocks.Add(new Paragraph());
 108 |         }
 109 |     }
 110 | }
 111 | 

// -----------------------------------
◈ End File: ViewModels\MainViewModel.cs
// ======================================================================

// ======================================================================
◇ Begin File: Views\MainWindow.xaml
// -----------------------------------

   1 | <Window x:Class="CodeConsolidator.MainWindow"<Window x:Class="CodeConsolidator.MainWindow"
   2 |         xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   3 |         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   4 |         Title="Code Exporter" Height="900" Width="1600"
   5 |         WindowStartupLocation="CenterScreen"
   6 |         Topmost="False" Icon="/Icons/icon_243.ico">
   7 |     <Grid x:Name="MainGrid">
   8 |         <Grid.RowDefinitions>
   9 |             <RowDefinition Height="Auto"/>
  10 |             <RowDefinition Height="*"/>
  11 |             <RowDefinition Height="Auto"/>
  12 |         </Grid.RowDefinitions>
  13 | 
  14 |         <StackPanel x:Name="TopControlPanel" Orientation="Horizontal" Grid.Row="0" Margin="5">
  15 |             <Button Content="Select Folder" Click="SelectFolderButton_Click" Margin="0 0 10 0"/>
  16 |             <CheckBox x:Name="RecursiveSearchCheckBox" <CheckBox x:Name="RecursiveSearchCheckBox" 
  17 |               Content="Search Subfolders" 
  18 |               VerticalAlignment="Center"
  19 |               Margin="0 0 10 0"
  20 |               IsChecked="True"/>
  21 |             <Button Content="Export Code" Click="ExportCodeButton_Click" Margin="0 0 10 0"/>
  22 |             <Button Content="Toggle Dark Mode" Click="ToggleDarkModeButton_Click" Margin="0 0 10 0"/>
  23 |             <Button Content="Refresh" Click="RefreshButton_Click" Margin="0 0 10 0"/>
  24 |             <Button Content="Clear" Click="ClearButton_Click" Margin="0 0 10 0"/>
  25 |             <TextBlock x:Name="StatusText" VerticalAlignment="Center" Margin="10 0 0 0" Foreground="Gray"/>
  26 |             <Button x:Name="PinButton" <Button x:Name="PinButton" 
  27 |         Click="PinButton_Click" 
  28 |         Margin="0 0 10 0"
  29 |         Width="24" 
  30 |         Height="24" 
  31 |         Padding="0">
  32 |                 <Image x:Name="PinIcon" <Image x:Name="PinIcon" 
  33 |            Width="16" 
  34 |            Height="16"/>
  35 |             </Button>
  36 |             
  37 |         </StackPanel>
  38 |         <RichTextBox x:Name="CodeDisplay" <RichTextBox x:Name="CodeDisplay" 
  39 |                      Grid.Row="1"
  40 |                      VerticalScrollBarVisibility="Auto"
  41 |                      HorizontalScrollBarVisibility="Auto"
  42 |                      FontFamily="Consolas"
  43 |                      FontSize="12"
  44 |                      IsReadOnly="True">
  45 |             <FlowDocument />
  46 |         </RichTextBox>
  47 |     </Grid>
  48 | </Window>
  49 |     

// -----------------------------------
◇ End File: Views\MainWindow.xaml
// ======================================================================

// ======================================================================
◈ Begin File: Views\MainWindow.xaml.cs
// -----------------------------------

   1 | using System;
   2 | using System.IO;
   3 | using System.Windows;
   4 | using System.Windows.Controls;
   5 | using System.Windows.Interop;
   6 | using System.Windows.Media;
   7 | using System.Windows.Media.Imaging;
   8 | using Microsoft.Win32;
   9 | using CodeConsolidator.Services;
  10 | using System.Runtime.InteropServices;
  11 | using System.Windows.Documents;
  12 | 
  13 | namespace CodeConsolidator
  14 | {
  15 |     public partial class MainWindow : Window
  16 |     {
  17 |         private ThemeService _themeService;
  18 |         private bool _darkMode = false;
  19 |         private ProgressBar _progressBar;
  20 |         private SyntaxHighlighter _syntaxHighlighter;
  21 |         private string _lastSelectedFolderPath;
  22 |         private bool _isPinned = false; // Tracks whether the window is pinned (topmost)
  23 |         private const string PinnedIconPath = "icon_233.png";
  24 |         private const string UnpinnedIconPath = "icon_228.png";
  25 | 
  26 |         public MainWindow()
  27 |         {
  28 |             InitializeComponent();
  29 |             InitializeProgressBar();
  30 |             EnsureIconsExist(); // Ensure icons are extracted and saved locally
  31 |             InitializePinButtonIcons();
  32 |             _syntaxHighlighter = new SyntaxHighlighter(_darkMode);
  33 |             _themeService = new ThemeService(this, CodeDisplay, StatusText, TopControlPanel);
  34 |         }
  35 | 
  36 |         /// <summary>
  37 |         /// Converts an icon handle to a BitmapSource for WPF.
  38 |         /// </summary>
  39 |         private BitmapSource LoadIconFromHandle(IntPtr hIcon)
  40 |         {
  41 |             if (hIcon == IntPtr.Zero)
  42 |             {
  43 |                 throw new ArgumentException("Icon handle cannot be null or zero.");
  44 |             }
  45 | 
  46 |             try
  47 |             {
  48 |                 return Imaging.CreateBitmapSourceFromHIcon(
  49 |                     hIcon,
  50 |                     Int32Rect.Empty, // Use the entire icon
  51 |                     BitmapSizeOptions.FromEmptyOptions() // No resizing
  52 |                 );
  53 |             }
  54 |             finally
  55 |             {
  56 |                 // Destroy the icon handle to avoid memory leaks
  57 |                 DestroyIcon(hIcon);
  58 |             }
  59 |         }
  60 | 
  61 |         /// <summary>
  62 |         /// Ensures that the required icons exist in the application directory.
  63 |         /// If not, extracts them from imageres.dll and saves them locally.
  64 |         /// </summary>
  65 |         private void EnsureIconsExist()
  66 |         {
  67 |             if (!File.Exists(PinnedIconPath))
  68 |             {
  69 |                 ExtractAndSaveIcon("imageres.dll", 129, PinnedIconPath); // Pinned icon
  70 |             }
  71 | 
  72 |             if (!File.Exists(UnpinnedIconPath))
  73 |             {
  74 |                 ExtractAndSaveIcon("imageres.dll", 130, UnpinnedIconPath); // Unpinned icon
  75 |             }
  76 |         }
  77 | 
  78 |         /// <summary>
  79 |         /// Extracts an icon from a DLL and saves it to the specified file path.
  80 |         /// </summary>
  81 |         private void ExtractAndSaveIcon(string dllName, int iconIndex, string outputPath)
  82 |         {
  83 |             // Load the icon from the DLL
  84 |             IntPtr hIcon = LoadImage(IntPtr.Zero, dllName, 1, 0, 0, (uint)(0x00000080 | iconIndex));
  85 |             if (hIcon == IntPtr.Zero)
  86 |             {
  87 |                 StatusText.Text = $"Failed to extract icon with index {iconIndex} from {dllName}.";
  88 |                 return;
  89 |             }
  90 | 
  91 |             try
  92 |             {
  93 |                 // Convert the icon handle to a System.Drawing.Icon
  94 |                 using (var icon = System.Drawing.Icon.FromHandle(hIcon))
  95 |                 {
  96 |                     // Save the icon to the specified file path
  97 |                     using (var stream = new FileStream(outputPath, FileMode.Create))
  98 |                     {
  99 |                         icon.Save(stream);
 100 |                     }
 101 |                 }
 102 |             }
 103 |             finally
 104 |             {
 105 |                 // Clean up the icon handle
 106 |                 DestroyIcon(hIcon);
 107 |             }
 108 |         }
 109 | 
 110 |         /// <summary>
 111 |         /// Initializes the pin button with the default "unpinned" icon.
 112 |         /// </summary>
 113 |         private void InitializePinButtonIcons()
 114 |         {
 115 |             // Load the initial "unpinned" icon
 116 |             PinIcon.Source = LoadIconFromFile(UnpinnedIconPath);
 117 |         }
 118 | 
 119 |         /// <summary>
 120 |         /// Handles the click event of the pin button.
 121 |         /// Toggles the window's Topmost property and updates the icon.
 122 |         /// </summary>
 123 |         private void PinButton_Click(object sender, RoutedEventArgs e)
 124 |         {
 125 |             _isPinned = !_isPinned;
 126 |             this.Topmost = _isPinned;
 127 | 
 128 |             // Change the icon based on the pinned state
 129 |             PinIcon.Source = _isPinned
 130 |                 ? LoadIconFromFile(PinnedIconPath) // Pinned icon
 131 |                 : LoadIconFromFile(UnpinnedIconPath); // Unpinned icon
 132 | 
 133 |             StatusText.Text = _isPinned
 134 |                 ? "Window is now pinned (always on top)."
 135 |                 : "Window is no longer pinned.";
 136 |         }
 137 | 
 138 |         /// <summary>
 139 |         /// Loads an icon from a local file.
 140 |         /// </summary>
 141 |         private BitmapSource LoadIconFromFile(string filePath)
 142 |         {
 143 |             if (File.Exists(filePath))
 144 |             {
 145 |                 return new BitmapImage(new Uri(filePath, UriKind.RelativeOrAbsolute));
 146 |             }
 147 | 
 148 |             StatusText.Text = $"Icon file not found: {filePath}";
 149 |             return null;
 150 |         }
 151 | 
 152 |         /// <summary>
 153 |         /// Initializes the progress bar control.
 154 |         /// </summary>
 155 |         private void InitializeProgressBar()
 156 |         {
 157 |             _progressBar = new ProgressBar
 158 |             {
 159 |                 Height = 5,
 160 |                 HorizontalAlignment = HorizontalAlignment.Stretch,
 161 |                 Margin = new Thickness(0, 5, 0, 0),
 162 |                 Visibility = Visibility.Collapsed
 163 |             };
 164 |             MainGrid.Children.Add(_progressBar);
 165 |             Grid.SetRow(_progressBar, 2);
 166 |         }
 167 | 
 168 |         /// <summary>
 169 |         /// Handles the folder selection process.
 170 |         /// </summary>
 171 |         private void SelectFolderButton_Click(object sender, RoutedEventArgs e)
 172 |         {
 173 |             var folderDialog = new OpenFolderDialog();
 174 |             if (folderDialog.ShowDialog() == true)
 175 |             {
 176 |                 ProcessSelectedFolder(folderDialog.FolderName);
 177 |             }
 178 |         }
 179 | 
 180 |         /// <summary>
 181 |         /// Processes the selected folder and displays its contents.
 182 |         /// </summary>
 183 |         private void ProcessSelectedFolder(string folderPath)
 184 |         {
 185 |             CodeDisplay.Document.Blocks.Clear();
 186 |             var filteredFiles = new List<string>();
 187 | 
 188 |             try
 189 |             {
 190 |                 _progressBar.Visibility = Visibility.Visible;
 191 |                 _progressBar.Value = 0;
 192 |                 StatusText.Text = "Searching files...";
 193 |                 Application.Current.Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Background);
 194 | 
 195 |                 var searchOption = RecursiveSearchCheckBox.IsChecked == true
 196 |                     ? SearchOption.AllDirectories
 197 |                     : SearchOption.TopDirectoryOnly;
 198 | 
 199 |                 var allFiles = Directory.GetFiles(folderPath, "*.*", searchOption);
 200 |                 var temporaryPatterns = new[] { "~$*", "*.tmp", "*.bak", "*.swp" };
 201 | 
 202 |                 filteredFiles = allFiles.Where(filePath =>
 203 |                 {
 204 |                     var fileName = Path.GetFileName(filePath);
 205 |                     var directoryName = Path.GetDirectoryName(filePath);
 206 |                     return !temporaryPatterns.Any(pattern => fileName.StartsWith(pattern.Trim('*'))) &&
 207 |                            !directoryName.Contains("bin") &&
 208 |                            !directoryName.Contains("obj") &&
 209 |                            !directoryName.Contains("deprecated") &&
 210 |                            !directoryName.Contains("Temp") &&
 211 |                            (filePath.EndsWith(".cs") || filePath.EndsWith(".xaml") || filePath.EndsWith(".sln") || filePath.EndsWith(".csproj"));
 212 | 
 213 |                 }).ToList();
 214 | 
 215 |                 _progressBar.Maximum = filteredFiles.Count;
 216 |                 var flowDocument = new FlowDocument();
 217 | 
 218 |                 foreach (var filePath in filteredFiles)
 219 |                 {
 220 |                     _progressBar.Value++;
 221 |                     StatusText.Text = $"Processing {_progressBar.Value} of {filteredFiles.Count}...";
 222 |                     Application.Current.Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Background);
 223 | 
 224 |                     // Add file header
 225 |                     var fileIcon = filePath.EndsWith(".cs") ? "◈" : filePath.EndsWith(".xaml") ? "◇" : "⚙";
 226 |                     var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue : filePath.EndsWith(".xaml") ? Brushes.Orange : Brushes.Green;
 227 | 
 228 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
 229 |                     {
 230 |                         Foreground = Brushes.Gray
 231 |                     });
 232 | 
 233 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} Begin File: {filePath.Substring(folderPath.Length + 1)}"))
 234 |                     {
 235 |                         Foreground = headerColor,
 236 |                         FontWeight = FontWeights.Bold
 237 |                     });
 238 | 
 239 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
 240 |                     {
 241 |                         Foreground = Brushes.Gray
 242 |                     });
 243 | 
 244 |                     flowDocument.Blocks.Add(new Paragraph());
 245 | 
 246 |                     // Add file content with syntax highlighting
 247 |                     var fileContent = File.ReadAllText(filePath);
 248 |                     if (filePath.EndsWith(".cs"))
 249 |                     {
 250 |                         _syntaxHighlighter.HighlightCSharpCode(fileContent, flowDocument);
 251 |                     }
 252 |                     else if (filePath.EndsWith(".xaml"))
 253 |                     {
 254 |                         _syntaxHighlighter.HighlightXamlCode(fileContent, flowDocument);
 255 |                     }
 256 |                     else if (filePath.EndsWith(".sln"))
 257 |                     {
 258 |                         _syntaxHighlighter.HighlightSlnCode(fileContent, flowDocument);
 259 |                     }
 260 |                     else if (filePath.EndsWith(".csproj"))
 261 |                     {
 262 |                         _syntaxHighlighter.HighlightCsProjCode(fileContent, flowDocument);
 263 |                     }
 264 | 
 265 |                     // Add file footer
 266 |                     flowDocument.Blocks.Add(new Paragraph());
 267 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
 268 |                     {
 269 |                         Foreground = Brushes.Gray
 270 |                     });
 271 | 
 272 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} End File: {filePath.Substring(folderPath.Length + 1)}"))
 273 |                     {
 274 |                         Foreground = headerColor,
 275 |                         FontWeight = FontWeights.Bold
 276 |                     });
 277 | 
 278 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
 279 |                     {
 280 |                         Foreground = Brushes.Gray
 281 |                     });
 282 | 
 283 |                     flowDocument.Blocks.Add(new Paragraph());
 284 |                 }
 285 | 
 286 |                 CodeDisplay.Document = flowDocument;
 287 |                 StatusText.Text = $"Loaded {filteredFiles.Count} files ({(RecursiveSearchCheckBox.IsChecked == true ? "recursive" : "non-recursive")})";
 288 |                 _progressBar.Visibility = Visibility.Collapsed;
 289 |                 _lastSelectedFolderPath = folderPath;
 290 |             }
 291 |             catch (Exception ex)
 292 |             {
 293 |                 MessageBox.Show($"Error processing files: {ex.Message}");
 294 |                 StatusText.Text = $"Error: {ex.Message} (loaded {filteredFiles.Count} files)";
 295 |                 _progressBar.Visibility = Visibility.Collapsed;
 296 |             }
 297 |         }
 298 | 
 299 |         /// <summary>
 300 |         /// Exports the displayed code to a text file.
 301 |         /// </summary>
 302 |         private void ExportCodeButton_Click(object sender, RoutedEventArgs e)
 303 |         {
 304 |             var baseFolderName = _lastSelectedFolderPath != null
 305 |                 ? Path.GetFileName(_lastSelectedFolderPath)
 306 |                 : "ExportedCode";
 307 | 
 308 |             var recursiveIndicator = RecursiveSearchCheckBox.IsChecked == true
 309 |                 ? "_Recursive"
 310 |                 : "_NonRecursive";
 311 | 
 312 |             var timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
 313 |             var defaultFileName = $"{baseFolderName}_CodeExport{recursiveIndicator}_{timestamp}.txt";
 314 | 
 315 |             var saveFileDialog = new SaveFileDialog
 316 |             {
 317 |                 Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*",
 318 |                 FileName = defaultFileName
 319 |             };
 320 | 
 321 |             if (saveFileDialog.ShowDialog() == true)
 322 |             {
 323 |                 try
 324 |                 {
 325 |                     var textRange = new TextRange(
 326 |                         CodeDisplay.Document.ContentStart,
 327 |                         CodeDisplay.Document.ContentEnd
 328 |                     );
 329 | 
 330 |                     File.WriteAllText(saveFileDialog.FileName, textRange.Text);
 331 |                     StatusText.Text = $"Successfully saved to {saveFileDialog.FileName}";
 332 |                 }
 333 |                 catch (Exception ex)
 334 |                 {
 335 |                     MessageBox.Show($"Error saving file: {ex.Message}");
 336 |                     StatusText.Text = $"Error: {ex.Message}";
 337 |                 }
 338 |             }
 339 |         }
 340 | 
 341 |         /// <summary>
 342 |         /// Toggles dark mode for the application.
 343 |         /// </summary>
 344 |         private void ToggleDarkModeButton_Click(object sender, RoutedEventArgs e)
 345 |         {
 346 |             ToggleDarkMode();
 347 |         }
 348 | 
 349 |         private void ToggleDarkMode()
 350 |         {
 351 |             _darkMode = !_darkMode;
 352 | 
 353 |             Background = _darkMode ? Brushes.DarkSlateGray : Brushes.White;
 354 |             Foreground = _darkMode ? Brushes.White : Brushes.Black;
 355 | 
 356 |             CodeDisplay.Background = _darkMode ? Brushes.DimGray : Brushes.White;
 357 |             CodeDisplay.Foreground = _darkMode ? Brushes.White : Brushes.Black;
 358 | 
 359 |             StatusText.Foreground = _darkMode ? Brushes.LightGray : Brushes.Gray;
 360 | 
 361 |             foreach (var child in TopControlPanel.Children)
 362 |             {
 363 |                 if (child is Button button)
 364 |                 {
 365 |                     button.Background = _darkMode ? Brushes.SlateGray : SystemColors.ControlBrush;
 366 |                     button.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
 367 |                 }
 368 |                 else if (child is CheckBox checkBox)
 369 |                 {
 370 |                     checkBox.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
 371 |                 }
 372 |             }
 373 | 
 374 |             _syntaxHighlighter = new SyntaxHighlighter(_darkMode);
 375 | 
 376 |             if (CodeDisplay.Document != null)
 377 |             {
 378 |                 var currentDoc = CodeDisplay.Document;
 379 |                 var tempDoc = new FlowDocument();
 380 |                 var range = new TextRange(currentDoc.ContentStart, currentDoc.ContentEnd);
 381 |                 var rangeNew = new TextRange(tempDoc.ContentStart, tempDoc.ContentEnd);
 382 |                 rangeNew.Text = range.Text;
 383 | 
 384 |                 CodeDisplay.Document = tempDoc;
 385 |                 CodeDisplay.Document = currentDoc;
 386 |             }
 387 |         }
 388 | 
 389 |         /// <summary>
 390 |         /// Refreshes the displayed folder contents.
 391 |         /// </summary>
 392 |         private void RefreshButton_Click(object sender, RoutedEventArgs e)
 393 |         {
 394 |             if (!string.IsNullOrEmpty(_lastSelectedFolderPath))
 395 |             {
 396 |                 ProcessSelectedFolder(_lastSelectedFolderPath);
 397 |             }
 398 |             else
 399 |             {
 400 |                 StatusText.Text = "No folder selected to refresh.";
 401 |             }
 402 |         }
 403 | 
 404 |         /// <summary>
 405 |         /// Clears the displayed code.
 406 |         /// </summary>
 407 |         private void ClearButton_Click(object sender, RoutedEventArgs e)
 408 |         {
 409 |             CodeDisplay.Document.Blocks.Clear();
 410 |             StatusText.Text = "Code display cleared.";
 411 |         }
 412 | 
 413 |         [DllImport("user32.dll", SetLastError = true)]
 414 |         private static extern IntPtr LoadImage(IntPtr hinst, string lpszName, uint uType, int cxDesired, int cyDesired, uint fuLoad);
 415 | 
 416 |         [DllImport("user32.dll", SetLastError = true)]
 417 |         private static extern bool DestroyIcon(IntPtr hIcon);
 418 |     }
 419 | }

// -----------------------------------
◈ End File: Views\MainWindow.xaml.cs
// ======================================================================

