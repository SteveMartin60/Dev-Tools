// ======================================================================
◇ Begin File: App.xaml
// -----------------------------------

   1 | <Application x:Class="CodeConsolidator.App"<Application x:Class="CodeConsolidator.App"
   2 |              xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   3 |              xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   4 |              StartupUri="Views/MainWindow.xaml">
   5 |     <Application.Resources>
   6 |     </Application.Resources>
   7 | </Application>

// -----------------------------------
◇ End File: App.xaml
// ======================================================================

// ======================================================================
◈ Begin File: App.xaml.cs
// -----------------------------------

   1 | using System.Configuration;
   2 | using System.Data;
   3 | using System.Windows;
   4 | 
   5 | namespace CodeConsolidator
   6 | {
   7 |     /// <summary>
   8 |     /// Interaction logic for App.xaml
   9 |     /// </summary>
  10 |     public partial class App : Application
  11 |     {
  12 |     }
  13 | 
  14 | }
  15 | 

// -----------------------------------
◈ End File: App.xaml.cs
// ======================================================================

// ======================================================================
◈ Begin File: AssemblyInfo.cs
// -----------------------------------

   1 | using System.Windows;
   2 | 
   3 | [assembly: ThemeInfo(
   4 |     ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
   5 |                                                 //(used if a resource is not found in the page,
   6 |                                                 // or application resource dictionaries)
   7 |     ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
   8 |                                                 //(used if a resource is not found in the page,
   9 |                                                 // app, or any theme specific resource dictionaries)
  10 | )]
  11 | 

// -----------------------------------
◈ End File: AssemblyInfo.cs
// ======================================================================

// ======================================================================
◈ Begin File: Models\FileProcessor.cs
// -----------------------------------

   1 | using System;
   2 | using System.Collections.Generic;
   3 | using System.IO;
   4 | 
   5 | namespace CodeConsolidator.Models
   6 | {
   7 |     public class FileProcessor
   8 |     {
   9 |         public List<string> GetFilteredFiles(string folderPath, bool searchSubfolders)
  10 |         {
  11 |             var filteredFiles = new List<string>();
  12 |             try
  13 |             {
  14 |                 var searchOption = searchSubfolders ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
  15 |                 var allFiles = Directory.GetFiles(folderPath, "*.*", searchOption);
  16 |                 var temporaryPatterns = new List<string> { "~$*", "*.tmp", "*.bak", "*.swp" };
  17 | 
  18 |                 filteredFiles = allFiles.Where(filePath =>
  19 |                 {
  20 |                     var fileName = Path.GetFileName(filePath);
  21 |                     var directoryName = Path.GetDirectoryName(filePath);
  22 | 
  23 |                     return !temporaryPatterns.Any(pattern => fileName.StartsWith(pattern.Trim('*'))) &&
  24 |                            !directoryName.Contains("bin") &&
  25 |                            !directoryName.Contains("obj") &&
  26 |                            !directoryName.Contains("deprecated") &&
  27 |                            !directoryName.Contains("Temp") &&
  28 |                            (filePath.EndsWith(".cs") || filePath.EndsWith(".xaml"));
  29 |                 }).ToList();
  30 |             }
  31 |             catch (Exception ex)
  32 |             {
  33 |                 throw new Exception($"Error processing files: {ex.Message}");
  34 |             }
  35 | 
  36 |             return filteredFiles;
  37 |         }
  38 |     }
  39 | }
  40 | 

// -----------------------------------
◈ End File: Models\FileProcessor.cs
// ======================================================================

// ======================================================================
◈ Begin File: Services\SyntaxHighlighter.cs
// -----------------------------------

   1 | using System;
   2 | using System.Linq;
   3 | using System.Windows;
   4 | using System.Windows.Documents;
   5 | using System.Windows.Media;
   6 | using System.Windows.Shapes;
   7 | 
   8 | namespace CodeConsolidator.Services
   9 | {
  10 |     public class SyntaxHighlighter
  11 |     {
  12 |         private readonly bool _darkMode;
  13 | 
  14 |         public SyntaxHighlighter(bool darkMode)
  15 |         {
  16 |             _darkMode = darkMode;
  17 |         }
  18 | 
  19 |         public void HighlightCSharpCode(string code, FlowDocument flowDocument)
  20 |         {
  21 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
  22 |             var keywords = new[] { "using", "namespace", "class", "void", "return", "if", "else", "for", "foreach", "while", "do", "switch", "case", "break", "continue", "var", "new", "this", "base", "true", "false", "null" };
  23 |             int lineNumber = 1;
  24 | 
  25 | 
  26 |             for (int i = 0; i < lines.Length; i++)
  27 |             //foreach (var line in lines)
  28 |             {
  29 |                 var line = lines[i];
  30 | 
  31 |                 var paragraph = CreateParagraph(lineNumber++, line);
  32 | 
  33 |                 foreach (var keyword in keywords)
  34 |                 {
  35 |                     int index = 0;
  36 |                     while (index >= 0 && index < line.Length)
  37 |                     {
  38 |                         index = line.IndexOf(keyword, index, StringComparison.Ordinal);
  39 |                         if (index < 0) break;
  40 | 
  41 |                         bool isWholeWord = (index == 0 || !char.IsLetterOrDigit(line[index - 1])) &&
  42 |                                            (index + keyword.Length >= line.Length ||
  43 |                                             !char.IsLetterOrDigit(line[index + keyword.Length]));
  44 | 
  45 |                         if (isWholeWord)
  46 |                         {
  47 |                             AddTextBeforeKeyword(paragraph, line.Substring(0, index));
  48 |                             AddHighlightedKeyword(paragraph, keyword);
  49 |                             line = line.Substring(index + keyword.Length);
  50 |                             index = 0;
  51 |                         }
  52 |                         else
  53 |                         {
  54 |                             index += keyword.Length;
  55 |                         }
  56 |                     }
  57 |                 }
  58 | 
  59 |                 AddRemainingText(paragraph, line);
  60 |                 flowDocument.Blocks.Add(paragraph);
  61 |             }
  62 |         }
  63 | 
  64 |         public void HighlightXamlCode(string code, FlowDocument flowDocument)
  65 |         {
  66 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
  67 |             int lineNumber = 1;
  68 | 
  69 |             foreach (var line in lines)
  70 |             {
  71 |                 var paragraph = CreateParagraph(lineNumber++, line);
  72 |                 var processedLine = line;
  73 | 
  74 |                 int tagStart = 0;
  75 |                 while ((tagStart = processedLine.IndexOf('<')) >= 0)
  76 |                 {
  77 |                     AddTextBeforeTag(paragraph, processedLine.Substring(0, tagStart));
  78 |                     processedLine = processedLine.Substring(tagStart);
  79 |                     tagStart = 0;
  80 | 
  81 |                     int tagEnd = processedLine.IndexOf('>');
  82 |                     if (tagEnd < 0)
  83 |                     {
  84 |                         AddUnclosedTag(paragraph, processedLine);
  85 |                         break;
  86 |                     }
  87 | 
  88 |                     var tag = processedLine.Substring(0, tagEnd + 1);
  89 |                     AddHighlightedTag(paragraph, tag);
  90 |                     processedLine = processedLine.Substring(tagEnd + 1);
  91 |                 }
  92 | 
  93 |                 AddRemainingText(paragraph, processedLine);
  94 |                 flowDocument.Blocks.Add(paragraph);
  95 |             }
  96 |         }
  97 | 
  98 |         public void HighlightSlnCode(string code, FlowDocument flowDocument)
  99 |         {
 100 |             var lines = code.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
 101 |             int lineNumber = 1;
 102 | 
 103 |             foreach (var line in lines)
 104 |             {
 105 |                 var paragraph = CreateParagraph(lineNumber++, line);
 106 | 
 107 |                 if (line.Trim().StartsWith("Project("))
 108 |                 {
 109 |                     // Highlight project references
 110 |                     AddHighlightedKeyword(paragraph, "Project");
 111 |                     AddTextBeforeKeyword(paragraph, line.Substring(0, line.IndexOf("Project")));
 112 |                     AddRemainingText(paragraph, line.Substring(line.IndexOf("Project") + "Project".Length));
 113 |                 }
 114 |                 else if (line.Trim().StartsWith("GlobalSection("))
 115 |                 {
 116 |                     // Highlight global sections
 117 |                     AddHighlightedKeyword(paragraph, "GlobalSection");
 118 |                     AddTextBeforeKeyword(paragraph, line.Substring(0, line.IndexOf("GlobalSection")));
 119 |                     AddRemainingText(paragraph, line.Substring(line.IndexOf("GlobalSection") + "GlobalSection".Length));
 120 |                 }
 121 |                 else
 122 |                 {
 123 |                     // Default text
 124 |                     AddRemainingText(paragraph, line);
 125 |                 }
 126 | 
 127 |                 flowDocument.Blocks.Add(paragraph);
 128 |             }
 129 |         }
 130 | 
 131 |         private Paragraph CreateParagraph(int lineNumber, string line)
 132 |         {
 133 |             var paragraph = new Paragraph();
 134 |             paragraph.Inlines.Add(new Run($"{lineNumber.ToString().PadLeft(4)} | ")
 135 |             {
 136 |                 Foreground = Brushes.Gray,
 137 |                 FontFamily = new FontFamily("Consolas")
 138 |             });
 139 |             return paragraph;
 140 |         }
 141 | 
 142 |         private void AddTextBeforeKeyword(Paragraph paragraph, string text)
 143 |         {
 144 |             paragraph.Inlines.Add(new Run(text));
 145 |         }
 146 | 
 147 |         private void AddHighlightedKeyword(Paragraph paragraph, string keyword)
 148 |         {
 149 |             paragraph.Inlines.Add(new Run(keyword)
 150 |             {
 151 |                 Foreground = _darkMode ? Brushes.LightBlue : Brushes.Blue,
 152 |                 FontWeight = FontWeights.Bold
 153 |             });
 154 |         }
 155 | 
 156 |         private void AddHighlightedTag(Paragraph paragraph, string tag)
 157 |         {
 158 |             paragraph.Inlines.Add(new Run(tag)
 159 |             {
 160 |                 Foreground = _darkMode ? Brushes.LightCoral : Brushes.DarkRed
 161 |             });
 162 |         }
 163 | 
 164 |         private void AddUnclosedTag(Paragraph paragraph, string tag)
 165 |         {
 166 |             paragraph.Inlines.Add(new Run(tag)
 167 |             {
 168 |                 Foreground = _darkMode ? Brushes.LightCoral : Brushes.DarkRed
 169 |             });
 170 |         }
 171 | 
 172 |         private void AddTextBeforeTag(Paragraph paragraph, string text)
 173 |         {
 174 |             paragraph.Inlines.Add(new Run(text));
 175 |         }
 176 | 
 177 |         private void AddRemainingText(Paragraph paragraph, string text)
 178 |         {
 179 |             if (!string.IsNullOrEmpty(text))
 180 |             {
 181 |                 paragraph.Inlines.Add(new Run(text));
 182 |             }
 183 |         }
 184 |     }
 185 | }
 186 | 

// -----------------------------------
◈ End File: Services\SyntaxHighlighter.cs
// ======================================================================

// ======================================================================
◈ Begin File: Services\ThemeService.cs
// -----------------------------------

   1 | using System.Windows;
   2 | using System.Windows.Controls;
   3 | using System.Windows.Media;
   4 | 
   5 | namespace CodeConsolidator.Services
   6 | {
   7 |     public class ThemeService
   8 |     {
   9 |         private readonly Window _window;
  10 |         private readonly RichTextBox _codeDisplay;
  11 |         private readonly TextBlock _statusText;
  12 |         private readonly Panel _controlPanel;
  13 | 
  14 |         private bool _darkMode;
  15 | 
  16 |         public ThemeService(Window window, RichTextBox codeDisplay, TextBlock statusText, Panel controlPanel)
  17 |         {
  18 |             _window = window;
  19 |             _codeDisplay = codeDisplay;
  20 |             _statusText = statusText;
  21 |             _controlPanel = controlPanel;
  22 |         }
  23 | 
  24 |         public bool IsDarkMode()
  25 |         {
  26 |             return _darkMode;
  27 |         }
  28 | 
  29 |         public void ToggleDarkMode()
  30 |         {
  31 |             _darkMode = !_darkMode;
  32 | 
  33 |             _window.Background = _darkMode ? Brushes.DarkSlateGray : Brushes.White;
  34 |             _window.Foreground = _darkMode ? Brushes.White : Brushes.Black;
  35 | 
  36 |             _codeDisplay.Background = _darkMode ? Brushes.DimGray : Brushes.White;
  37 |             _codeDisplay.Foreground = _darkMode ? Brushes.White : Brushes.Black;
  38 | 
  39 |             _statusText.Foreground = _darkMode ? Brushes.LightGray : Brushes.Gray;
  40 | 
  41 |             foreach (var child in _controlPanel.Children)
  42 |             {
  43 |                 if (child is Button button)
  44 |                 {
  45 |                     button.Background = _darkMode ? Brushes.SlateGray : SystemColors.ControlBrush;
  46 |                     button.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
  47 |                 }
  48 |                 else if (child is CheckBox checkBox)
  49 |                 {
  50 |                     checkBox.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
  51 |                 }
  52 |             }
  53 |         }
  54 |     }
  55 | }
  56 | 

// -----------------------------------
◈ End File: Services\ThemeService.cs
// ======================================================================

// ======================================================================
◈ Begin File: ViewModels\MainViewModel.cs
// -----------------------------------

   1 | using CodeConsolidator.Models;
   2 | using CodeConsolidator.Services;
   3 | using System.Collections.Generic;
   4 | using System.IO;
   5 | using System.Windows;
   6 | using System.Windows.Documents;
   7 | using System.Windows.Media;
   8 | 
   9 | namespace CodeConsolidator.ViewModels
  10 | {
  11 |     public class MainViewModel
  12 |     {
  13 |         private readonly FileProcessor _fileProcessor;
  14 |         private readonly SyntaxHighlighter _syntaxHighlighter;
  15 | 
  16 |         public MainViewModel(bool darkMode)
  17 |         {
  18 |             _fileProcessor = new FileProcessor();
  19 |             _syntaxHighlighter = new SyntaxHighlighter(darkMode);
  20 |         }
  21 | 
  22 |         public void ProcessFolder(string folderPath, bool recursive, FlowDocument flowDocument)
  23 |         {
  24 |             var filteredFiles = _fileProcessor.GetFilteredFiles(folderPath, recursive);
  25 | 
  26 |             flowDocument.Blocks.Clear();
  27 | 
  28 |             foreach (var filePath in filteredFiles)
  29 |             {
  30 |                 AddFileHeader(flowDocument, filePath, folderPath);
  31 |                 var fileContent = File.ReadAllText(filePath);
  32 | 
  33 |                 if (filePath.EndsWith(".cs"))
  34 |                 {
  35 |                     _syntaxHighlighter.HighlightCSharpCode(fileContent, flowDocument);
  36 |                 }
  37 |                 else if (filePath.EndsWith(".xaml"))
  38 |                 {
  39 |                     _syntaxHighlighter.HighlightXamlCode(fileContent, flowDocument);
  40 |                 }
  41 | 
  42 |                 AddFileFooter(flowDocument, filePath, folderPath);
  43 |             }
  44 |         }
  45 | 
  46 |         private void AddFileHeader(FlowDocument flowDocument, string filePath, string folderPath)
  47 |         {
  48 |             string fileIcon = filePath.EndsWith(".cs") ? "◈" : filePath.EndsWith(".xaml") ? "◇" : "⚙";
  49 |             var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue : filePath.EndsWith(".xaml") ? Brushes.Orange : Brushes.Green;
  50 | 
  51 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
  52 |             {
  53 |                 Foreground = Brushes.Gray
  54 |             });
  55 | 
  56 |             flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} Begin File: {filePath.Substring(folderPath.Length + 1)}"))
  57 |             {
  58 |                 Foreground = headerColor,
  59 |                 FontWeight = FontWeights.Bold
  60 |             });
  61 | 
  62 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
  63 |             {
  64 |                 Foreground = Brushes.Gray
  65 |             });
  66 | 
  67 |             flowDocument.Blocks.Add(new Paragraph());
  68 |         }
  69 | 
  70 |         private void AddFileFooter(FlowDocument flowDocument, string filePath, string folderPath)
  71 |         {
  72 |             string fileIcon = filePath.EndsWith(".cs") ? "◈" : filePath.EndsWith(".xaml") ? "◇" : "⚙";
  73 |             var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue : filePath.EndsWith(".xaml") ? Brushes.Orange : Brushes.Green;
  74 | 
  75 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
  76 |             {
  77 |                 Foreground = Brushes.Gray
  78 |             });
  79 | 
  80 |             flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} End File: {filePath.Substring(folderPath.Length + 1)}"))
  81 |             {
  82 |                 Foreground = headerColor,
  83 |                 FontWeight = FontWeights.Bold
  84 |             });
  85 | 
  86 |             flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
  87 |             {
  88 |                 Foreground = Brushes.Gray
  89 |             });
  90 | 
  91 |             flowDocument.Blocks.Add(new Paragraph());
  92 |         }
  93 |     }
  94 | }
  95 | 

// -----------------------------------
◈ End File: ViewModels\MainViewModel.cs
// ======================================================================

// ======================================================================
◇ Begin File: Views\MainWindow.xaml
// -----------------------------------

   1 | <Window x:Class="CodeConsolidator.MainWindow"<Window x:Class="CodeConsolidator.MainWindow"
   2 |         xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   3 |         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   4 |         Title="Code Exporter" Height="900" Width="1600"
   5 |         WindowStartupLocation="CenterScreen"
   6 |         Topmost="False" Icon="/Icons/icon_243.ico">
   7 |     <Grid x:Name="MainGrid">
   8 |         <Grid.RowDefinitions>
   9 |             <RowDefinition Height="Auto"/>
  10 |             <RowDefinition Height="*"/>
  11 |             <RowDefinition Height="Auto"/>
  12 |         </Grid.RowDefinitions>
  13 | 
  14 |         <StackPanel x:Name="TopControlPanel" Orientation="Horizontal" Grid.Row="0" Margin="5">
  15 |             <Button Content="Select Folder" Click="SelectFolderButton_Click" Margin="0 0 10 0"/>
  16 |             <CheckBox x:Name="RecursiveSearchCheckBox" <CheckBox x:Name="RecursiveSearchCheckBox" 
  17 |               Content="Search Subfolders" 
  18 |               VerticalAlignment="Center"
  19 |               Margin="0 0 10 0"
  20 |               IsChecked="True"/>
  21 |             <Button Content="Export Code" Click="ExportCodeButton_Click" Margin="0 0 10 0"/>
  22 |             <Button Content="Toggle Dark Mode" Click="ToggleDarkModeButton_Click" Margin="0 0 10 0"/>
  23 |             <Button Content="Refresh" Click="RefreshButton_Click" Margin="0 0 10 0"/>
  24 |             <Button Content="Clear" Click="ClearButton_Click" Margin="0 0 10 0"/>
  25 |             <TextBlock x:Name="StatusText" VerticalAlignment="Center" Margin="10 0 0 0" Foreground="Gray"/>
  26 |             <Button x:Name="PinButton" <Button x:Name="PinButton" 
  27 |         Click="PinButton_Click" 
  28 |         Margin="0 0 10 0"
  29 |         Width="24" 
  30 |         Height="24" 
  31 |         Padding="0">
  32 |                 <Image x:Name="PinIcon" <Image x:Name="PinIcon" 
  33 |            Width="16" 
  34 |            Height="16"/>
  35 |             </Button>
  36 |             
  37 |         </StackPanel>
  38 |         <RichTextBox x:Name="CodeDisplay" <RichTextBox x:Name="CodeDisplay" 
  39 |                      Grid.Row="1"
  40 |                      VerticalScrollBarVisibility="Auto"
  41 |                      HorizontalScrollBarVisibility="Auto"
  42 |                      FontFamily="Consolas"
  43 |                      FontSize="12"
  44 |                      IsReadOnly="True">
  45 |             <FlowDocument />
  46 |         </RichTextBox>
  47 |     </Grid>
  48 | </Window>
  49 |     

// -----------------------------------
◇ End File: Views\MainWindow.xaml
// ======================================================================

// ======================================================================
◈ Begin File: Views\MainWindow.xaml.cs
// -----------------------------------

   1 | using System;
   2 | using System.IO;
   3 | using System.Windows;
   4 | using System.Windows.Controls;
   5 | using System.Windows.Interop;
   6 | using System.Windows.Media;
   7 | using System.Windows.Media.Imaging;
   8 | using Microsoft.Win32;
   9 | using CodeConsolidator.Services;
  10 | using System.Runtime.InteropServices;
  11 | using System.Windows.Documents;
  12 | 
  13 | namespace CodeConsolidator
  14 | {
  15 |     public partial class MainWindow : Window
  16 |     {
  17 |         private ThemeService _themeService;
  18 |         private bool _darkMode = false;
  19 |         private ProgressBar _progressBar;
  20 |         private SyntaxHighlighter _syntaxHighlighter;
  21 |         private string _lastSelectedFolderPath;
  22 |         private bool _isPinned = false; // Tracks whether the window is pinned (topmost)
  23 |         private const string PinnedIconPath = "icon_233.png";
  24 |         private const string UnpinnedIconPath = "icon_228.png";
  25 | 
  26 |         public MainWindow()
  27 |         {
  28 |             InitializeComponent();
  29 |             InitializeProgressBar();
  30 |             EnsureIconsExist(); // Ensure icons are extracted and saved locally
  31 |             InitializePinButtonIcons();
  32 |             _syntaxHighlighter = new SyntaxHighlighter(_darkMode);
  33 |             _themeService = new ThemeService(this, CodeDisplay, StatusText, TopControlPanel);
  34 |         }
  35 | 
  36 |         /// <summary>
  37 |         /// Converts an icon handle to a BitmapSource for WPF.
  38 |         /// </summary>
  39 |         private BitmapSource LoadIconFromHandle(IntPtr hIcon)
  40 |         {
  41 |             if (hIcon == IntPtr.Zero)
  42 |             {
  43 |                 throw new ArgumentException("Icon handle cannot be null or zero.");
  44 |             }
  45 | 
  46 |             try
  47 |             {
  48 |                 return Imaging.CreateBitmapSourceFromHIcon(
  49 |                     hIcon,
  50 |                     Int32Rect.Empty, // Use the entire icon
  51 |                     BitmapSizeOptions.FromEmptyOptions() // No resizing
  52 |                 );
  53 |             }
  54 |             finally
  55 |             {
  56 |                 // Destroy the icon handle to avoid memory leaks
  57 |                 DestroyIcon(hIcon);
  58 |             }
  59 |         }
  60 | 
  61 |         /// <summary>
  62 |         /// Ensures that the required icons exist in the application directory.
  63 |         /// If not, extracts them from imageres.dll and saves them locally.
  64 |         /// </summary>
  65 |         private void EnsureIconsExist()
  66 |         {
  67 |             if (!File.Exists(PinnedIconPath))
  68 |             {
  69 |                 ExtractAndSaveIcon("imageres.dll", 129, PinnedIconPath); // Pinned icon
  70 |             }
  71 | 
  72 |             if (!File.Exists(UnpinnedIconPath))
  73 |             {
  74 |                 ExtractAndSaveIcon("imageres.dll", 130, UnpinnedIconPath); // Unpinned icon
  75 |             }
  76 |         }
  77 | 
  78 |         /// <summary>
  79 |         /// Extracts an icon from a DLL and saves it to the specified file path.
  80 |         /// </summary>
  81 |         private void ExtractAndSaveIcon(string dllName, int iconIndex, string outputPath)
  82 |         {
  83 |             // Load the icon from the DLL
  84 |             IntPtr hIcon = LoadImage(IntPtr.Zero, dllName, 1, 0, 0, (uint)(0x00000080 | iconIndex));
  85 |             if (hIcon == IntPtr.Zero)
  86 |             {
  87 |                 StatusText.Text = $"Failed to extract icon with index {iconIndex} from {dllName}.";
  88 |                 return;
  89 |             }
  90 | 
  91 |             try
  92 |             {
  93 |                 // Convert the icon handle to a System.Drawing.Icon
  94 |                 using (var icon = System.Drawing.Icon.FromHandle(hIcon))
  95 |                 {
  96 |                     // Save the icon to the specified file path
  97 |                     using (var stream = new FileStream(outputPath, FileMode.Create))
  98 |                     {
  99 |                         icon.Save(stream);
 100 |                     }
 101 |                 }
 102 |             }
 103 |             finally
 104 |             {
 105 |                 // Clean up the icon handle
 106 |                 DestroyIcon(hIcon);
 107 |             }
 108 |         }
 109 | 
 110 |         /// <summary>
 111 |         /// Initializes the pin button with the default "unpinned" icon.
 112 |         /// </summary>
 113 |         private void InitializePinButtonIcons()
 114 |         {
 115 |             // Load the initial "unpinned" icon
 116 |             PinIcon.Source = LoadIconFromFile(UnpinnedIconPath);
 117 |         }
 118 | 
 119 |         /// <summary>
 120 |         /// Handles the click event of the pin button.
 121 |         /// Toggles the window's Topmost property and updates the icon.
 122 |         /// </summary>
 123 |         private void PinButton_Click(object sender, RoutedEventArgs e)
 124 |         {
 125 |             _isPinned = !_isPinned;
 126 |             this.Topmost = _isPinned;
 127 | 
 128 |             // Change the icon based on the pinned state
 129 |             PinIcon.Source = _isPinned
 130 |                 ? LoadIconFromFile(PinnedIconPath) // Pinned icon
 131 |                 : LoadIconFromFile(UnpinnedIconPath); // Unpinned icon
 132 | 
 133 |             StatusText.Text = _isPinned
 134 |                 ? "Window is now pinned (always on top)."
 135 |                 : "Window is no longer pinned.";
 136 |         }
 137 | 
 138 |         /// <summary>
 139 |         /// Loads an icon from a local file.
 140 |         /// </summary>
 141 |         private BitmapSource LoadIconFromFile(string filePath)
 142 |         {
 143 |             if (File.Exists(filePath))
 144 |             {
 145 |                 return new BitmapImage(new Uri(filePath, UriKind.RelativeOrAbsolute));
 146 |             }
 147 | 
 148 |             StatusText.Text = $"Icon file not found: {filePath}";
 149 |             return null;
 150 |         }
 151 | 
 152 |         /// <summary>
 153 |         /// Initializes the progress bar control.
 154 |         /// </summary>
 155 |         private void InitializeProgressBar()
 156 |         {
 157 |             _progressBar = new ProgressBar
 158 |             {
 159 |                 Height = 5,
 160 |                 HorizontalAlignment = HorizontalAlignment.Stretch,
 161 |                 Margin = new Thickness(0, 5, 0, 0),
 162 |                 Visibility = Visibility.Collapsed
 163 |             };
 164 |             MainGrid.Children.Add(_progressBar);
 165 |             Grid.SetRow(_progressBar, 2);
 166 |         }
 167 | 
 168 |         /// <summary>
 169 |         /// Handles the folder selection process.
 170 |         /// </summary>
 171 |         private void SelectFolderButton_Click(object sender, RoutedEventArgs e)
 172 |         {
 173 |             var folderDialog = new OpenFolderDialog();
 174 |             if (folderDialog.ShowDialog() == true)
 175 |             {
 176 |                 ProcessSelectedFolder(folderDialog.FolderName);
 177 |             }
 178 |         }
 179 | 
 180 |         /// <summary>
 181 |         /// Processes the selected folder and displays its contents.
 182 |         /// </summary>
 183 |         private void ProcessSelectedFolder(string folderPath)
 184 |         {
 185 |             CodeDisplay.Document.Blocks.Clear();
 186 |             var filteredFiles = new List<string>();
 187 | 
 188 |             try
 189 |             {
 190 |                 _progressBar.Visibility = Visibility.Visible;
 191 |                 _progressBar.Value = 0;
 192 |                 StatusText.Text = "Searching files...";
 193 |                 Application.Current.Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Background);
 194 | 
 195 |                 var searchOption = RecursiveSearchCheckBox.IsChecked == true
 196 |                     ? SearchOption.AllDirectories
 197 |                     : SearchOption.TopDirectoryOnly;
 198 | 
 199 |                 var allFiles = Directory.GetFiles(folderPath, "*.*", searchOption);
 200 |                 var temporaryPatterns = new[] { "~$*", "*.tmp", "*.bak", "*.swp" };
 201 | 
 202 |                 filteredFiles = allFiles.Where(filePath =>
 203 |                 {
 204 |                     var fileName = Path.GetFileName(filePath);
 205 |                     var directoryName = Path.GetDirectoryName(filePath);
 206 |                     return !temporaryPatterns.Any(pattern => fileName.StartsWith(pattern.Trim('*'))) &&
 207 |                            !directoryName.Contains("bin") &&
 208 |                            !directoryName.Contains("obj") &&
 209 |                            !directoryName.Contains("deprecated") &&
 210 |                            !directoryName.Contains("Temp") &&
 211 |                            (filePath.EndsWith(".cs") || filePath.EndsWith(".xaml") || filePath.EndsWith(".sln"));
 212 |                 }).ToList();
 213 | 
 214 |                 _progressBar.Maximum = filteredFiles.Count;
 215 |                 var flowDocument = new FlowDocument();
 216 | 
 217 |                 foreach (var filePath in filteredFiles)
 218 |                 {
 219 |                     _progressBar.Value++;
 220 |                     StatusText.Text = $"Processing {_progressBar.Value} of {filteredFiles.Count}...";
 221 |                     Application.Current.Dispatcher.Invoke(() => { }, System.Windows.Threading.DispatcherPriority.Background);
 222 | 
 223 |                     // Add file header
 224 |                     var fileIcon = filePath.EndsWith(".cs") ? "◈" : filePath.EndsWith(".xaml") ? "◇" : "⚙";
 225 |                     var headerColor = filePath.EndsWith(".cs") ? Brushes.DodgerBlue : filePath.EndsWith(".xaml") ? Brushes.Orange : Brushes.Green;
 226 | 
 227 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
 228 |                     {
 229 |                         Foreground = Brushes.Gray
 230 |                     });
 231 | 
 232 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} Begin File: {filePath.Substring(folderPath.Length + 1)}"))
 233 |                     {
 234 |                         Foreground = headerColor,
 235 |                         FontWeight = FontWeights.Bold
 236 |                     });
 237 | 
 238 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
 239 |                     {
 240 |                         Foreground = Brushes.Gray
 241 |                     });
 242 | 
 243 |                     flowDocument.Blocks.Add(new Paragraph());
 244 | 
 245 |                     // Add file content with syntax highlighting
 246 |                     var fileContent = File.ReadAllText(filePath);
 247 |                     if (filePath.EndsWith(".cs"))
 248 |                     {
 249 |                         _syntaxHighlighter.HighlightCSharpCode(fileContent, flowDocument);
 250 |                     }
 251 |                     else if (filePath.EndsWith(".xaml"))
 252 |                     {
 253 |                         _syntaxHighlighter.HighlightXamlCode(fileContent, flowDocument);
 254 |                     }
 255 |                     else if (filePath.EndsWith(".sln"))
 256 |                     {
 257 |                         _syntaxHighlighter.HighlightSlnCode(fileContent, flowDocument);
 258 |                     }
 259 | 
 260 |                     // Add file footer
 261 |                     flowDocument.Blocks.Add(new Paragraph());
 262 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// -----------------------------------"))
 263 |                     {
 264 |                         Foreground = Brushes.Gray
 265 |                     });
 266 | 
 267 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"{fileIcon} End File: {filePath.Substring(folderPath.Length + 1)}"))
 268 |                     {
 269 |                         Foreground = headerColor,
 270 |                         FontWeight = FontWeights.Bold
 271 |                     });
 272 | 
 273 |                     flowDocument.Blocks.Add(new Paragraph(new Run($"// ======================================================================"))
 274 |                     {
 275 |                         Foreground = Brushes.Gray
 276 |                     });
 277 | 
 278 |                     flowDocument.Blocks.Add(new Paragraph());
 279 |                 }
 280 | 
 281 |                 CodeDisplay.Document = flowDocument;
 282 |                 StatusText.Text = $"Loaded {filteredFiles.Count} files ({(RecursiveSearchCheckBox.IsChecked == true ? "recursive" : "non-recursive")})";
 283 |                 _progressBar.Visibility = Visibility.Collapsed;
 284 |                 _lastSelectedFolderPath = folderPath;
 285 |             }
 286 |             catch (Exception ex)
 287 |             {
 288 |                 MessageBox.Show($"Error processing files: {ex.Message}");
 289 |                 StatusText.Text = $"Error: {ex.Message} (loaded {filteredFiles.Count} files)";
 290 |                 _progressBar.Visibility = Visibility.Collapsed;
 291 |             }
 292 |         }
 293 | 
 294 |         /// <summary>
 295 |         /// Exports the displayed code to a text file.
 296 |         /// </summary>
 297 |         private void ExportCodeButton_Click(object sender, RoutedEventArgs e)
 298 |         {
 299 |             var baseFolderName = _lastSelectedFolderPath != null
 300 |                 ? Path.GetFileName(_lastSelectedFolderPath)
 301 |                 : "ExportedCode";
 302 | 
 303 |             var recursiveIndicator = RecursiveSearchCheckBox.IsChecked == true
 304 |                 ? "_Recursive"
 305 |                 : "_NonRecursive";
 306 | 
 307 |             var timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
 308 |             var defaultFileName = $"{baseFolderName}_CodeExport{recursiveIndicator}_{timestamp}.txt";
 309 | 
 310 |             var saveFileDialog = new SaveFileDialog
 311 |             {
 312 |                 Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*",
 313 |                 FileName = defaultFileName
 314 |             };
 315 | 
 316 |             if (saveFileDialog.ShowDialog() == true)
 317 |             {
 318 |                 try
 319 |                 {
 320 |                     var textRange = new TextRange(
 321 |                         CodeDisplay.Document.ContentStart,
 322 |                         CodeDisplay.Document.ContentEnd
 323 |                     );
 324 | 
 325 |                     File.WriteAllText(saveFileDialog.FileName, textRange.Text);
 326 |                     StatusText.Text = $"Successfully saved to {saveFileDialog.FileName}";
 327 |                 }
 328 |                 catch (Exception ex)
 329 |                 {
 330 |                     MessageBox.Show($"Error saving file: {ex.Message}");
 331 |                     StatusText.Text = $"Error: {ex.Message}";
 332 |                 }
 333 |             }
 334 |         }
 335 | 
 336 |         /// <summary>
 337 |         /// Toggles dark mode for the application.
 338 |         /// </summary>
 339 |         private void ToggleDarkModeButton_Click(object sender, RoutedEventArgs e)
 340 |         {
 341 |             ToggleDarkMode();
 342 |         }
 343 | 
 344 |         private void ToggleDarkMode()
 345 |         {
 346 |             _darkMode = !_darkMode;
 347 | 
 348 |             Background = _darkMode ? Brushes.DarkSlateGray : Brushes.White;
 349 |             Foreground = _darkMode ? Brushes.White : Brushes.Black;
 350 | 
 351 |             CodeDisplay.Background = _darkMode ? Brushes.DimGray : Brushes.White;
 352 |             CodeDisplay.Foreground = _darkMode ? Brushes.White : Brushes.Black;
 353 | 
 354 |             StatusText.Foreground = _darkMode ? Brushes.LightGray : Brushes.Gray;
 355 | 
 356 |             foreach (var child in TopControlPanel.Children)
 357 |             {
 358 |                 if (child is Button button)
 359 |                 {
 360 |                     button.Background = _darkMode ? Brushes.SlateGray : SystemColors.ControlBrush;
 361 |                     button.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
 362 |                 }
 363 |                 else if (child is CheckBox checkBox)
 364 |                 {
 365 |                     checkBox.Foreground = _darkMode ? Brushes.White : SystemColors.ControlTextBrush;
 366 |                 }
 367 |             }
 368 | 
 369 |             _syntaxHighlighter = new SyntaxHighlighter(_darkMode);
 370 | 
 371 |             if (CodeDisplay.Document != null)
 372 |             {
 373 |                 var currentDoc = CodeDisplay.Document;
 374 |                 var tempDoc = new FlowDocument();
 375 |                 var range = new TextRange(currentDoc.ContentStart, currentDoc.ContentEnd);
 376 |                 var rangeNew = new TextRange(tempDoc.ContentStart, tempDoc.ContentEnd);
 377 |                 rangeNew.Text = range.Text;
 378 | 
 379 |                 CodeDisplay.Document = tempDoc;
 380 |                 CodeDisplay.Document = currentDoc;
 381 |             }
 382 |         }
 383 | 
 384 |         /// <summary>
 385 |         /// Refreshes the displayed folder contents.
 386 |         /// </summary>
 387 |         private void RefreshButton_Click(object sender, RoutedEventArgs e)
 388 |         {
 389 |             if (!string.IsNullOrEmpty(_lastSelectedFolderPath))
 390 |             {
 391 |                 ProcessSelectedFolder(_lastSelectedFolderPath);
 392 |             }
 393 |             else
 394 |             {
 395 |                 StatusText.Text = "No folder selected to refresh.";
 396 |             }
 397 |         }
 398 | 
 399 |         /// <summary>
 400 |         /// Clears the displayed code.
 401 |         /// </summary>
 402 |         private void ClearButton_Click(object sender, RoutedEventArgs e)
 403 |         {
 404 |             CodeDisplay.Document.Blocks.Clear();
 405 |             StatusText.Text = "Code display cleared.";
 406 |         }
 407 | 
 408 |         [DllImport("user32.dll", SetLastError = true)]
 409 |         private static extern IntPtr LoadImage(IntPtr hinst, string lpszName, uint uType, int cxDesired, int cyDesired, uint fuLoad);
 410 | 
 411 |         [DllImport("user32.dll", SetLastError = true)]
 412 |         private static extern bool DestroyIcon(IntPtr hIcon);
 413 |     }
 414 | }

// -----------------------------------
◈ End File: Views\MainWindow.xaml.cs
// ======================================================================

